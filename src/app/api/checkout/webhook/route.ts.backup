import { NextRequest, NextResponse } from 'next/server';
import { stripeService } from '@/services/StripeService';
import { messageService } from '@/services/MessageService';
import { slugService } from '@/services/SlugService';
import { qrCodeService } from '@/services/QRCodeService';
import { emailService } from '@/services/EmailService';
import { validateStoredURLs } from '@/lib/utils';
import Stripe from 'stripe';
import { promises as fs } from 'fs';
import path from 'path';

/**
 * POST /api/checkout/webhook
 * Handles Stripe webhook events for payment processing
 * 
 * Requirements: 2.2, 2.3, 2.4, 2.5, 3.1, 3.2, 3.3
 * 
 * @param request - Next.js request object
 * @returns JSON response with success status or error
 */
export async function POST(request: NextRequest) {
  try {
    // Get raw body as text for signature verification (Requirement 2.5)
    const body = await request.text();
    
    // Get Stripe signature from headers (Requirement 2.5)
    const signature = request.headers.get('stripe-signature');
    
    if (!signature) {
      console.error('Missing stripe-signature header');
      return NextResponse.json(
        {
          error: {
            code: 'MISSING_SIGNATURE',
            message: 'Missing Stripe signature header',
          },
        },
        { status: 400 }
      );
    }

    // Verify webhook signature (Requirement 2.5)
    let event: Stripe.Event;
    try {
      event = stripeService.constructWebhookEvent(body, signature);
    } catch (error) {
      console.error('Webhook signature verification failed:', error);
      return NextResponse.json(
        {
          error: {
            code: 'INVALID_SIGNATURE',
            message: 'Invalid webhook signature',
          },
        },
        { status: 400 }
      );
    }

    // Handle 'checkout.session.completed' event (Requirement 2.2)
    if (event.type === 'checkout.session.completed') {
      const session = event.data.object as Stripe.Checkout.Session;
      
      // NOTA: Código PIX comentado - reativar quando PIX estiver disponível no Stripe
      // Para PIX, verificar se o pagamento foi realmente concluído
      // PIX pode ter status 'unpaid' quando o QR code é gerado
      // if (session.payment_status === 'unpaid') {
      //   console.log(`Checkout session ${session.id} completed but payment is unpaid (PIX QR code generated)`);
      //   // Não processar ainda, aguardar evento 'checkout.session.async_payment_succeeded'
      //   return NextResponse.json(
      //     { received: true, message: 'PIX QR code generated, awaiting payment' },
      //     { status: 200 }
      //   );
      // }
      
      try {
        // Extract messageId from session metadata (Requirement 2.2)
        const messageId = stripeService.handleSuccessfulPayment(session);
        
        // Verify message exists
        const message = await messageService.findById(messageId);
        
        if (!message) {
          console.error(`Message not found for ID: ${messageId}`);
          return NextResponse.json(
            {
              error: {
                code: 'MESSAGE_NOT_FOUND',
                message: 'Message not found',
              },
            },
            { status: 404 }
          );
        }

        // Update message status to 'paid' (Requirements 2.2, 2.3)
        await messageService.updateStatus(messageId, 'paid');
        
        // Generate slug using SlugService (Requirement 3.1)
        const slug = slugService.generateSlug(message.recipientName, messageId);
        
        // Generate full URL for QR code
        const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
        const fullUrl = `${baseUrl}${slug}`;
        
        // Generate QR code using QRCodeService (Requirements 3.2, 3.3)
        const qrCodeUrl = await qrCodeService.generate(fullUrl, messageId);
        
        // Update message with slug and qrCodeUrl (Requirements 3.1, 3.2, 3.3)
        await messageService.updateQRCode(messageId, qrCodeUrl, slug);
        
        // Validate URL accessibility (Requirement 6.5)
        const urlValidation = await validateStoredURLs(
          message.imageUrl,
          qrCodeUrl,
          {
            maxRetries: 3,
            retryDelay: 1000,
            timeout: 5000,
          }
        );
        
        if (!urlValidation.allAccessible) {
          console.warn('Warning: Some URLs may not be immediately accessible', {
            messageId,
            imageUrl: urlValidation.imageUrl,
            qrCodeUrl: urlValidation.qrCodeUrl,
          });
        }
        
        // Send QR code email (Requirements 12.1, 12.5, 12.6, 12.7)
        try {
          console.log('[Webhook] Starting email send process for message:', messageId);
          
          // Read QR code file and convert to base64 data URL
          const qrCodePath = path.join(process.cwd(), 'public', qrCodeUrl);
          console.log('[Webhook] Reading QR code from:', qrCodePath);
          
          const qrCodeBuffer = await fs.readFile(qrCodePath);
          const qrCodeBase64 = qrCodeBuffer.toString('base64');
          const qrCodeDataUrl = `data:image/png;base64,${qrCodeBase64}`;
          
          console.log('[Webhook] QR code loaded, size:', qrCodeBuffer.length, 'bytes');
          
          // Get contact email from session metadata or message database
          const contactEmail = session.customer_details?.email || session.metadata?.contactEmail || message.contactEmail;
          const contactName = session.metadata?.contactName || message.contactName || message.senderName;
          
          console.log('[Webhook] Email delivery check:', {
            sessionEmail: session.customer_details?.email,
            metadataEmail: session.metadata?.contactEmail,
            messageEmail: message.contactEmail,
            finalEmail: contactEmail,
            contactName: contactName,
          });
          
          if (contactEmail) {
            console.log('[Webhook] Preparing to send email to:', contactEmail);
            
            // Send email with QR code (Requirement 12.1)
            const emailData = {
              recipientEmail: contactEmail,
              recipientName: contactName,
              messageUrl: fullUrl,
              qrCodeDataUrl: qrCodeDataUrl,
              senderName: message.senderName,
              messageTitle: message.title || `Mensagem para ${message.recipientName}`,
            };
            
            console.log('[Webhook] Email data prepared:', {
              recipientEmail: emailData.recipientEmail,
              recipientName: emailData.recipientName,
              messageUrl: emailData.messageUrl,
              senderName: emailData.senderName,
              messageTitle: emailData.messageTitle,
              qrCodeSize: qrCodeDataUrl.length,
            });
            
            console.log('[Webhook] Calling emailService.sendQRCodeEmail...');
            const emailResult = await emailService.sendQRCodeEmail(emailData);
            
            if (emailResult.success) {
              console.log(`[Webhook] ✅ Successfully sent QR code email for message ${messageId}`, {
                emailMessageId: emailResult.messageId,
                recipientEmail: contactEmail,
              });
            } else {
              // Handle email send failures gracefully (Requirement 12.5)
              // Log but don't block the webhook response
              console.error(`[Webhook] ❌ Failed to send QR code email for message ${messageId}`, {
                error: emailResult.error,
                recipientEmail: contactEmail,
              });
            }
          } else {
            console.warn(`[Webhook] ⚠️ No contact email found for message ${messageId}, skipping email send`);
            console.warn('[Webhook] Available data:', {
              sessionCustomerEmail: session.customer_details?.email,
              sessionMetadataEmail: session.metadata?.contactEmail,
              messageContactEmail: message.contactEmail,
            });
          }
        } catch (emailError) {
          // Handle email send failures gracefully (Requirement 12.5)
          // Log but don't block the webhook response
          console.error('[Webhook] ❌ Error sending QR code email:', {
            messageId,
            error: emailError instanceof Error ? emailError.message : 'Unknown error',
            stack: emailError instanceof Error ? emailError.stack : undefined,
          });
        }
        
        console.log(`Successfully processed payment for message ${messageId}`);
      } catch (error) {
        console.error('Error processing successful payment:', error);
        // Return 200 to Stripe even if processing fails to avoid retries
        // Log the error for manual investigation
        return NextResponse.json(
          { received: true, error: 'Processing failed but acknowledged' },
          { status: 200 }
        );
      }
    }

    // EVENTOS PIX - COMENTADOS (Reativar quando PIX estiver disponível no Stripe)
    // 
    // Handle 'checkout.session.async_payment_succeeded' event
    // Este evento é disparado quando um pagamento PIX é confirmado
    // if (event.type === 'checkout.session.async_payment_succeeded') {
    //   const session = event.data.object as Stripe.Checkout.Session;
    //   
    //   try {
    //     console.log(`PIX payment succeeded for session ${session.id}`);
    //     
    //     // Extract messageId from session metadata
    //     const messageId = stripeService.handleSuccessfulPayment(session);
    //     
    //     // Verify message exists
    //     const message = await messageService.findById(messageId);
    //     
    //     if (!message) {
    //       console.error(`Message not found for ID: ${messageId}`);
    //       return NextResponse.json(
    //         {
    //           error: {
    //             code: 'MESSAGE_NOT_FOUND',
    //             message: 'Message not found',
    //           },
    //         },
    //         { status: 404 }
    //       );
    //     }

        // Update message status to 'paid'
        await messageService.updateStatus(messageId, 'paid');
        
        // Generate slug using SlugService
        const slug = slugService.generateSlug(message.recipientName, messageId);
        
        // Generate full URL for QR code
        const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
        const fullUrl = `${baseUrl}${slug}`;
        
        // Generate QR code using QRCodeService
        const qrCodeUrl = await qrCodeService.generate(fullUrl, messageId);
        
        // Update message with slug and qrCodeUrl
        await messageService.updateQRCode(messageId, qrCodeUrl, slug);
        
        // Validate URL accessibility
        const urlValidation = await validateStoredURLs(
          message.imageUrl,
          qrCodeUrl,
          {
            maxRetries: 3,
            retryDelay: 1000,
            timeout: 5000,
          }
        );
        
        if (!urlValidation.allAccessible) {
          console.warn('Warning: Some URLs may not be immediately accessible', {
            messageId,
            imageUrl: urlValidation.imageUrl,
            qrCodeUrl: urlValidation.qrCodeUrl,
          });
        }
        
        // Send QR code email
        try {
          console.log('[Webhook PIX] Starting email send process for message:', messageId);
          
          // Read QR code file and convert to base64 data URL
          const qrCodePath = path.join(process.cwd(), 'public', qrCodeUrl);
          console.log('[Webhook PIX] Reading QR code from:', qrCodePath);
          
          const qrCodeBuffer = await fs.readFile(qrCodePath);
          const qrCodeBase64 = qrCodeBuffer.toString('base64');
          const qrCodeDataUrl = `data:image/png;base64,${qrCodeBase64}`;
          
          console.log('[Webhook PIX] QR code loaded, size:', qrCodeBuffer.length, 'bytes');
          
          // Get contact email from session metadata or message database
          const contactEmail = session.customer_details?.email || session.metadata?.contactEmail || message.contactEmail;
          const contactName = session.metadata?.contactName || message.contactName || message.senderName;
          
          console.log('[Webhook PIX] Email delivery check:', {
            sessionEmail: session.customer_details?.email,
            metadataEmail: session.metadata?.contactEmail,
            messageEmail: message.contactEmail,
            finalEmail: contactEmail,
            contactName: contactName,
          });
          
          if (contactEmail) {
            console.log('[Webhook PIX] Preparing to send email to:', contactEmail);
            
            // Send email with QR code
            const emailData = {
              recipientEmail: contactEmail,
              recipientName: contactName,
              messageUrl: fullUrl,
              qrCodeDataUrl: qrCodeDataUrl,
              senderName: message.senderName,
              messageTitle: message.title || `Mensagem para ${message.recipientName}`,
            };
            
            console.log('[Webhook PIX] Email data prepared:', {
              recipientEmail: emailData.recipientEmail,
              recipientName: emailData.recipientName,
              messageUrl: emailData.messageUrl,
              senderName: emailData.senderName,
              messageTitle: emailData.messageTitle,
              qrCodeSize: qrCodeDataUrl.length,
            });
            
            console.log('[Webhook PIX] Calling emailService.sendQRCodeEmail...');
            const emailResult = await emailService.sendQRCodeEmail(emailData);
            
            if (emailResult.success) {
              console.log(`[Webhook PIX] ✅ Successfully sent QR code email for message ${messageId}`, {
                emailMessageId: emailResult.messageId,
                recipientEmail: contactEmail,
              });
            } else {
              console.error(`[Webhook PIX] ❌ Failed to send QR code email for message ${messageId}`, {
                error: emailResult.error,
                recipientEmail: contactEmail,
              });
            }
          } else {
            console.warn(`[Webhook PIX] ⚠️ No contact email found for message ${messageId}, skipping email send`);
          }
        } catch (emailError) {
          console.error('[Webhook PIX] ❌ Error sending QR code email:', {
            messageId,
            error: emailError instanceof Error ? emailError.message : 'Unknown error',
            stack: emailError instanceof Error ? emailError.stack : undefined,
          });
        }
        
        console.log(`Successfully processed PIX payment for message ${messageId}`);
      } catch (error) {
        console.error('Error processing PIX payment:', error);
        // Return 200 to Stripe even if processing fails to avoid retries
        return NextResponse.json(
          { received: true, error: 'Processing failed but acknowledged' },
          { status: 200 }
        );
      }
    }

    // Handle 'checkout.session.async_payment_failed' event
    // Este evento é disparado quando um pagamento PIX falha ou expira
    if (event.type === 'checkout.session.async_payment_failed') {
      const session = event.data.object as Stripe.Checkout.Session;
      console.log(`PIX payment failed for session ${session.id}`);
      
      // Opcional: você pode adicionar lógica para notificar o usuário
      // ou atualizar o status da mensagem para 'payment_failed'
    }

    // Return 200 response to Stripe (Requirement 2.5)
    return NextResponse.json(
      { received: true },
      { status: 200 }
    );
  } catch (error) {
    // Handle unexpected errors
    console.error('Error in POST /api/checkout/webhook:', error);
    
    // Return 500 for unexpected errors
    return NextResponse.json(
      {
        error: {
          code: 'INTERNAL_ERROR',
          message: 'An unexpected error occurred while processing webhook',
        },
      },
      { status: 500 }
    );
  }
}
